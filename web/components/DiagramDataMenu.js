import InteractiVenn from '../javascript.js';
import { d3 } from '../d3/d3.v2.js';
import { saveAs} from '../d3/FileSaver.js';
import { ColorInput } from "./ColorInput.js";
import { SetService, intersections, intersectionsSet } from '../utils/SetService.js';

const { getBrowserName } = InteractiVenn;

export function DataMenu({ allSetsIDs, changeColor , colorBoxRefs, colors, dataSets, diagramConfig, handleDatasetUpdate, handleSetDiagramConfig }) {
  const element = React.createElement;

  const { nWay } = diagramConfig;

  // Methods
  /**
   * @description Clears all data sets.
   * @param {Array} allSetsIDs The IDs of the sets to clear.
   * @param {Frray} handleDatasetUpdate The method to update datasets state.
   */
  function clearSets() {

    const tempDatasets = {};
    allSetsIDs.forEach(setId => tempDatasets[setId] = { data: [] });

    const alltextarea = d3.selectAll("textarea")[0];
    for (var i = 0; i < alltextarea.length; i++) {
        alltextarea[i].value = "";
    }

    handleDatasetUpdate(tempDatasets);
    updateIntersections({ allSetsIDs, dataSets: tempDatasets });
  }

  function handleFileSelect(evt) {
    var files = evt.target.files; // FileList object
    // files is a FileList of File objects. List some properties.           
    for (var i = 0, f; f = files[i]; i++) {
        loadSets(f, allSetsIDs, handleDatasetUpdate, handleSetDiagramConfig);
    }
  }

  function loadSets(f) {
    var reader = new FileReader();
    // Closure to capture the file information

    reader.onload = function (e) {
        var str = e.target.result.replace(/\n/g, "");
        var setsList = str.split(";");
        setsList = setsList.filter(function (x) {
            if (x != "")
                return true;
        });

        const nWay = setsList.length;
        const path = "../diagrams/" + nWay + "/" + nWay + "waydiagram.svg";
    
        handleSetDiagramConfig({ nWay, path });

        const newData = {};
        for (var i = 0; i < setsList.length; i++) {
            var setName = allSetsIDs[i];
            var setlist = setsList[i].split(":");
            newData[setName] = { label: setlist[0].replace(/^\r+|^\s+/,'') };

            setlist[1] = setlist[1].split(",");
            var list = setlist[1].filter(function (x) {
                if (x != "")
                    return true;
            });

            newData[setName].data = list;
        }

        handleDatasetUpdate(newData);
        updateIntersections({ allSetsIDs, dataSets: newData });
    };
    reader.readAsText(f);
  }

  /**
   * @description Updates the text file that represents the texts and exports the sets in .ivenn format.
   */
  function saveDataset() {
    var bname = getBrowserName();
    if( bname == "Safari"){
        alert("You are using Safari and it does not support Blob type. Exporting the dataset probably will not work. Please consider to use the Chrome or Firefox web browsers.");
    }
    updateFile2Save();
    const document_name = document.getElementById("dataset-name").value + ".ivenn";
    //alert("Saving dataset as "+document_name+". It may take some seconds.");
    const dataset = document.getElementById("data_set_content").value;
    saveAs(new Blob([dataset], {type: "text/plain;charset=" + document.characterSet}), document_name);
    return false;
  }

  /**
   * @description Updates the string that represents the sets in form of a text to be exported as .ivenn format. The download is generated by the user and this text is considered on the interaction.
   */
  function updateFile2Save() {
    var file = "";

    const { nWay } = diagramConfig;

    for (var i = 0; i < nWay; i++) {
        var setID = allSetsIDs[i];
        var setname = dataSets[setID].label;
        var data = dataSets[setID].data.length > 1 ? dataSets[setID].data.join[', '] : dataSets[setID].data.toString().replace(/\[\]/g, '');
        file += setname + ":" + data ;
        if (i < nWay - 1) { file += ";\n"; }
    }
    document.getElementById("data_set_content").value = file;
  }

  /**
   * @description Analyses the sets and rebuild the lists of intersections.
   */
  function updateIntersections() {
    //Union of all sets
    const setsVector = allSetsIDs.map(name => dataSets[name].data);
    const setService = new SetService(allSetsIDs, dataSets);
    var totalSet = setService.getUnionOfAllSetsArray(setsVector);

    //Hash of sets; easy way to know if an element is in a set or not
    var hash = {};
    for (var i = 0; i < allSetsIDs.length; i++) {
        hash[allSetsIDs[i]] = {};
    }

    for (var i = 0; i < allSetsIDs.length; i++) {
        for (var j = 0; j < dataSets[allSetsIDs[i]].data.length; j++) {
            hash[allSetsIDs[i]][dataSets[allSetsIDs[i]].data[j]] = true;
        }
    }

    // Clear existing objects
    const intersectionsKeys = Object.keys(intersections);
    intersectionsKeys.forEach(key => delete intersections[key]);

    const intersectionsSetKeys = Object.keys(intersectionsSet);
    intersectionsSetKeys.forEach(key => delete intersectionsSet[key]);

    //computes all possible intersections
    for (var j = 0; j < totalSet.length; j++) {
        var intersectionID = "";
        var currentElement = totalSet[j];
        for (var k = 0; k < allSetsIDs.length; k++) {
            if (hash[allSetsIDs[k]][currentElement] == true) {
                intersectionID = intersectionID + allSetsIDs[k];
            }
        }

        if (intersectionsSet[intersectionID] == null) {
            intersectionsSet[intersectionID] = [];
        }
        intersectionsSet[intersectionID].push(currentElement);
        if (intersections[intersectionID] == null || intersections[intersectionID] == 0) {
            intersections[intersectionID] = 1;
        } else {
            intersections[intersectionID]++;
        }
    }
  }

  /**
  * @description Updates the lists of elements of a set and its intersections. Updates the global variable "sets" changing these values. Calls UpdateIntersections().
  * @param {string} setID The set ID.
  * @param {string} value The new value of the set.
  */
  function updateSets({ diagramConfig, handleDatasetUpdate, setID, value }) {

  if (!diagramConfig.isMerging) {

      let initialList = value.split("\n");
      for (var t = 0; t < initialList.length; t++)
      {
        initialList[t] = initialList[t].replace(/^\s+/g, "");
        initialList[t] = initialList[t].replace(/\s+$/g, "");
      }
      const remove = ["", "\n", " ", "  ", "   "];
      initialList = initialList.filter(x => remove.includes(x) === false && x !== '');

      const list = Array.from(new Set(initialList));
      if(list.length !== initialList.length) alert(`Problem in Set ${setID}: there are duplicated elements in at least one of your lists. We try and remove duplicates before showing the intersections in the diagram, but we don't remove the duplicates from the input-boxes that are on the right-side. We recommend you to input always sets (lists of unique values). The numbers in the website are respective to the number of unique values that we found, and not the number of elements in your lists when they have duplicates. You can continue the analysis if you are aware of the differences between a set and a list with duplicated elements.`);

      const newData = {};
      newData[setID] = { data: list };
      handleDatasetUpdate(newData);
  
    }
    updateIntersections();
  }

  // Subcomponents
  const saveSetsInputProps = {
    type: 'text', 
    className: 'filename',
    id: 'dataset-name', 
    size: '23',
    placeholder: 'Write dataset name here'
  }
  const saveSetsInput = element(
    'label',
    null,
    element(
      'input',
      saveSetsInputProps,
      null,
    ),
    '.ivenn',
  );

  const loadSetsElement = element(
    'p',
    null,
    'Load sets: ',
    element('input', { type: 'file', id: 'files', name: 'files', lang: 'en-US', text: 'Load dataset', onChange: (e) => handleFileSelect(e) }, null),
    element('br', null)
  )

  const sampleDataset = element(
    'p',
    null,
    element('strong', null, 'Sample data set'),
    element('br', null),
    element('a', { href: 'test_model.ivenn', style: { fontSize: '12px' }, download: true }, 'Simple Model'),
    element('br', null),
  )

  return (
    element(
      'div',
      { style: { fontSize: '12px', width: '30%', padding: '0px' }},
      NumSets(handleSetDiagramConfig, diagramConfig),
      ...allSetsIDs.slice(0, nWay).map((setID, i) => SetBlock({ dataSets, diagramConfig, setID, handleDatasetUpdate, colorBoxRef: colorBoxRefs[i], colors, changeColor, updateSets })),
      element('button', { type: 'button', id: 'clearSets', disabled: diagramConfig.isMerging, onClick: () => clearSets() }, 'Clear sets'),
      element('p', { style: { marginBottom: '0px' }}, 'Save sets:'),
      saveSetsInput,
      element('button', { id: 'saveDataset', value: 'Save', type: 'button', onClick: () => saveDataset() }, 'Save'),
      element('input', { type: 'hidden', lang: 'en-US', id: 'data_set_content' }, null),
      loadSetsElement,
      sampleDataset,
    )
  )
}

function NumSets(handleSetDiagramConfig, diagramConfig) {
  const element = React.createElement;

  const inputs = [2, 3, 4, 5, 6];
  const getPath = (nWay) => "../diagrams/" + nWay + "/" + nWay + "waydiagram.svg";

  const form = element(
    'form',
    { style: { display: 'flex', justifyItems: 'flex-start' }},
    ...inputs.map(num => (
      element(
        'div',
        { style: { display: 'flex', alignItems: 'center' }},
        element(
          'input',
          { id: `nway${num}`, type: 'radio', disabled: diagramConfig.isMerging, name:'nwayRadio', checked: num === diagramConfig.nWay ? true: false, value: num, onChange: () => { handleSetDiagramConfig({ nWay: num, path: getPath(num) })}},
          null,
        ),
        element(
          'label', 
          { htmlFor: `nway${num}`, style: { padding: '5px 8px 0px 0px' } },
          num
        )
      )
    )
  ));

  return (
    element(
      'div',
      { style: { margin: '12px 0px'}},
      'Number of Sets: ',
      form,
    )
  )
}

function SetBlock({ dataSets, diagramConfig, setID, handleDatasetUpdate, colorBoxRef, colors, changeColor, updateSets }) {
  const element = React.createElement;

  // Methods
  const handleLabelUpdate = (e, setID) => {
    const newValue = e.target.value;
    const newData = {};
    newData[setID] = {};
    newData[setID].label = newValue;
    handleDatasetUpdate(newData);
  }

  //Subcomponents
  const defaultName = dataSets[setID] ? dataSets[setID].label : `Set ${setID}`;
  const nameInput = element(
    'input',
    { id: `name${setID}`, size: '15', maxLength: '15', defaultValue: defaultName, style: { fontWeight: 'bold' }, onChange: (e) => handleLabelUpdate(e, setID) },
  )

  const colorInput = element(ColorInput, { changeColor, setID, colorBoxRef, colors } )
  const color = element(
    'div',
    { style: { display: 'inline' }, disabled: diagramConfig},
    colorInput,
  )

  const elements = element(
    'div',
    { id: `elements${setID}`, className: 'elementsN', style: { display: 'inline' }},
  )

  const defaultValue = dataSets[setID].data.length > 0 ?  dataSets[setID].data.join('\n') : '';
  const textarea = element(
    'textarea',
    { id: `input${setID}`, disabled: diagramConfig.isMerging, className: 'input', defaultValue, style: { width: '90%' }, rows: '3', onChange: (e) => { updateSets({  diagramConfig, handleDatasetUpdate, setID, value: e.currentTarget.value }); } }
  )

  return (
    element(
      'div',
      null,
      `${setID}: `,
      nameInput,
      color,
      elements,
      element('br', null),
      textarea,
    )
  )
};
